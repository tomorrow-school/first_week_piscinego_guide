# Quest 2. PrintCombN

## Название файла Go
`printcombn.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function that prints all possible combinations of n different digits in ascending order. n will be defined as 0<n<10. * | *Напишите функцию, которая выводит все возможные комбинации из n различных цифр в порядке возрастания. n будет определено как 0<n<10.* |

---

## Разбор задания: PrintCombN

* Функция: func PrintCombN(n int)
* Параметр: n — количество цифр в комбинации (1≤n≤9).
* Условие: Комбинация должна состоять из n различных цифр и быть в порядке возрастания (например, 012 для n=3).
* Формат вывода:
    * Комбинации должны быть в лексикографическом порядке возрастания.
    * Комбинации разделены запятой и пробелом (, ), кроме последней.
* Пример вывода:
    * Для n=1: 0, 1, 2, 3, ... 8, 9
    * Для n=3: 012, 013, 014, 015, 016, 017, 018, 019, 023, ... 789
* Ограничение: Задание требует обратить внимание на эффективность программы, чтобы избежать превышения лимита времени (timeout).

---

## Решение

```go
package piscine

var firstRun bool = true

func generateComb(currentDigit, minVal int, n int, comb []int) {
    if currentDigit == n {

            z01.PrintRune(',')
            z01.PrintRune(' ')
        }
        firstRun = false

        for _, digit := range comb {
            z01.PrintRune(rune(digit + '0'))
        }
        return
    }
    maxVal := 10 - (n - currentDigit)
    
    for val := minVal; val <= maxVal; val++ {
        comb[currentDigit] = val
        generateComb(currentDigit + 1, val + 1, n, comb)
    }

func PrintCombN(n int) {
    if n <= 0 || n >= 10 {
        return
    }

    firstRun = true 

    comb := make([]int, n) 
}

```

## Разбор логики решения

Это обобщение задания PrintComb (которое было для n=3). Поскольку количество циклов (n) заранее не известно, единственно правильным подходом является использование рекурсии (backtracking) для генерации комбинаций.

---

## Ключевые понятия

| **Инструмент / элемент кода** | **Объяснение и назначение** |
|-------------------------------|------------------------------|
| **func PrintCombN(n int)** | Основная функция. Принимает параметр n — количество цифр в комбинации (1≤n≤9). Отвечает за инициализацию рекурсивного процесса и вспомогательных структур (например, флага firstRun). |
| **generateComb(...)** | Рекурсивная (вспомогательная) функция. Выполняет основную логику: строит комбинацию по одной цифре. |
| **Параметр currentDigit** | Текущий индекс. Показывает, какую по счёту цифру (от 0 до n−1) мы сейчас пытаемся установить. |
| **Параметр minVal** | Минимальное значение. Определяет, с какой цифры должен начинаться перебор в текущем цикле. Передаётся как val+1 из предыдущего вызова, гарантируя, что цифратек.​>цифрапред.​ |
| **Базовый случай if currentDigit == n** | Условие печати. Означает, что срез comb заполнен n цифрами, и комбинация готова к выводу. |
| **if !firstRun { ... }** | Управление разделителем. Условие, которое проверяет, была ли уже напечатана хотя бы одна комбинация. Если да, печатает разделитель , перед текущей комбинацией, но не перед первой. |
| **maxVal := 10 - (n - currentDigit)** | Граничное условие/Оптимизация. Вычисляет самую большую цифру, которую может принять текущий разряд. Например, при n=4, на первой позиции (currentDigit=0) максимальное значение 6 (чтобы оставить место для 7,8,9). |
| **Цикл for val := minVal; val <= maxVal; val++** | Перебор цифр. Перебирает все возможные значения для текущего разряда. Использует minVal для обеспечения возрастания и maxVal для эффективности. |
| **comb[currentDigit] = val** | Сборка комбинации. Записывает выбранную цифру в соответствующую позицию среза. |
| **Рекурсивный шаг generateComb(currentDigit + 1, val + 1, ...)** | Переход к следующей цифре. Вызывает себя для следующего разряда (currentDigit+1), устанавливая новое минимальное значение val+1 для сохранения порядка возрастания. |
| **z01.PrintRune(rune(digit + '0'))** | СВывод. Печатает каждую цифру, предварительно преобразуя её из числового значения в руну-символ. |

---

## Глоссарий

| **Термин** | **Понятное объяснение** |
|-------------|--------------------------|
| **n** | Параметр. Целое число, которое определяет, сколько различных цифр должно быть в каждой комбинации (например, n=3 даёт 012). По условию, 1<n<10. |
| **Рекурсия** | Метод решения. Техника программирования, где функция вызывает саму себя. Используется в этом задании для генерации комбинаций, когда количество цифр (циклов) (n) заранее не известно. |
| **Обход с возвратом (Backtracking)** | Алгоритм. Стратегия перебора, тесно связанная с рекурсией. Она строит решение пошагово и, если текущий путь не ведёт к валидному результату, возвращается на шаг назад, чтобы попробовать другой вариант. |
| **Строгое возрастание** | Ограничение. Каждая последующая цифра в комбинации должна быть строго больше предыдущей (цифра1​<цифра2​<⋯<цифраn​). |
| **Лексикографический порядок** | Порядок вывода. Способ сортировки, используемый в словарях: комбинации сравниваются по цифрам слева направо (012 идет перед 013). |
| **Базовый случай рекурсии** | Условие завершения. Точка, в которой рекурсивная функция останавливается и выполняет финальное действие (в данном случае, когда комбинация из n цифр полностью собрана, она печатается). |
| **Граничное условие (maxVal)** | Оптимизация. Расчёт максимального значения, которое может принять текущая цифра. Это предотвращает бесполезные рекурсивные вызовы, гарантируя, что для оставшихся позиций хватит цифр до 9. |
| **Эффективность / Timeout** | Требование к скорости. Указывает на необходимость писать код, который работает быстро, поскольку полный перебор без оптимизации может привести к превышению лимита времени выполнения (таймауту). |
| **Флаг firstRun** | Управление форматированием. Переменная (часто булева), используемая для того, чтобы напечатать разделитель (, ) перед всеми комбинациями, кроме самой первой. |
| **Срез ([]int или []rune)** | Хранение данных. Структура данных (список), используемая для временного хранения n цифр текущей собираемой комбинации. |

---

## Заключение
Задание PrintCombN — это продвинутое упражнение, которое проверяет умение обобщать задачи и применять рекурсию (или обход с возвратом) для решения проблем с переменным числом циклов.

1. Обобщение: Успешное решение требует перехода от императивного подхода с фиксированными циклами (как в n=3) к гибкому рекурсивному алгоритму.
2. Эффективность: Правильное использование граничного условия maxVal (ранний выход из цикла) критически важно для производительности, поскольку позволяет алгоритму избегать перебора заведомо невалидных веток (например, 8xx при n=3).
3. Сложность: Задача включает одновременное управление порядком (строгое возрастание) и форматированием вывода (корректное размещение разделителей).
