# Quest 3.8 — StrRev (reverse)

## Название файла Go
`strrev.go`

---

## Условия задания 

| **Instruction** | **Перевод** |
|---------------------------|--------------|
| *Write a function that returns a string which is the reverse of the input string.* | *Напишите функцию, которая принимает строку и возвращает новую строку, где порядок символов обратный* |

Нужно написать функцию, которая принимает строку `s` и возвращает новую строку, где порядок символов обратный. Функция должна корректно работать с Unicode-символами (рунами) 

### Пример использования

```go
package main

import (
	"fmt"
	"piscine"
)

func main() {
	fmt.Println(piscine.StrRev("Hello World!")) // !dlroW olleH
	fmt.Println(piscine.StrRev("Привет"))       // тевирП
	fmt.Println(piscine.StrRev("猫"))           // 猫
}
```

**Ожидаемый вывод:**
```
!dlroW olleH
тевирП
猫
```

---

## Решение

```go
package piscine

func StrRev(s string) string {
	// Преобразуем строку в срез рун так мы работаем с символами, а не с байтами
	runes := []rune(s)

	// Делаем реверс на месте путем обмена парных элементов
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 { // здесь: i:=0, j:=len(runes)-1; обновление индексов: i = i+1, j = j - 1
		runes[i], runes[j] = runes[j], runes[i]    // здесь: runes[i] = runes[j] и наоборот
	}
	// Конвертируем срез рун обратно в строку
	return string(runes)
}
```

---

## Ключевые понятия / Инструменты

| **Элемент** | **Объяснение** |
|-------------|----------------|
| `string` | В Go строка это последовательность байтов в кодировке UTF-8. |
| `rune` | Тип `int32`, представляет собой Unicode code point (символ). Работа с `rune` нужна для корректной обработки многобайтовых символов. |
| `[]rune(var)` | Преобразование строки в срез рун — превращает последовательность байтов в последовательность символов (runes). |
| in-place reversal | Реверсирование среза без выделения нового среза (меняем элементы попарно). |
| `string(runes)` | Преобразование среза рун обратно в строку. |
| Перебор по байтам или рунам | Перебирать и реверсить по байтам (`[]byte`) ломает UTF-8 для многобайтовых символов (кириллица, эмодзи, и т.д.). <br> Для символов ASCII работает перебор по байтам так как 1 символ = 1 байт |

---

## Руны, UTF-8 и почему это важно

1. **UTF-8 в Go**  
   Go хранит строки в UTF-8. Символы разных языков занимают разное число байтов:
   - латинские буквы — 1 байт, кириллица — 2 байта, некоторые иероглифы и эмодзи — 3–4 байта.
 **Примечание: `len(s)` возвращает количество байтов, а не символов. Чтобы получить реальные символы, нужно преобразовать `[]rune(s)`.**

2. **Почему `[]rune`**  
   `[]rune` разбивает строку на кодовые точки (runes). После этого каждый элемент равен одному символу, и их можно безопасно перебирать и реверсить.

3. **Производительность**  
   Преобразование `[]rune(s)` аллоцирует новый срез (копию). Для учебных задач и большинства реальных случаев это нормально.

**Полезные ссылки для изучения**
- Official Go (strings & runes): https://go.dev/blog/strings  
- Metanit — строки и руны (на русском): https://metanit.com/go/tutorial/4.6.php  
---

## Логика и пошаговый разбор кода

### 1. Преобразование в `[]rune`
```go
runes := []rune(s)
```
Создаем срез рун `runes` из нашей строки `s`; теперь каждый элемент `runes[i]` это единичный символ 
Это необходимо чтобы не разрезать многобайтовые символы (например кириллица) на части.

### 2. Реверс на месте
```go
for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
    runes[i], runes[j] = runes[j], runes[i]
}
```
Используем два индекса: `i` идёт слева направо, а `j` справа налево.
Поменяв местами пары до середины, получаем инвертированный порядок.

### 3. Возврат результата
```go
return string(runes)
```
Преобразуем срез рун обратно в строку, которую возвращаем вызывающему коду.

---

## Пример итераций (визуализация)

Для `s = "Go!"`:
- `runes = ['G','o','!']`
- Проход: `(i=0,j=2)` → swap → `['!','o','G']`
- Результат: `"!oG"`

Для `s = "Пр"` (каждый символ 2 байта):
- `runes = ['П','р']` — безопасно, не ломаем кодировку.

---

## Частые ошибки и рекомендации

- **Реверс по байтам** (`[]byte`) — ломает UTF-8: у вас могут получиться битые символы.
- **Эмодзи и комбинирующие символы**: некоторые визуально единые символы могут состоять из нескольких code points (комбинации); `[]rune` реверсит именно code points, что обычно ожидаемо, но есть случаи (комплексные emoji) где поведение может быть неинтуитивным.

---

## Заключение

- Для корректного реверса строк с Unicode всегда используйте `[]rune`.  
- Реверс «на месте» через обмен парных элементов — простой и эффективный при учебных задачах.  
- Помните о разнице между байтами и символами: `len(s)` ≠ количество символов, если строка содержит многобайтовые символы.

