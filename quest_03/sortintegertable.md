# Quest 3.12 - SortIntegerTable

## Название файла Go
`sortintegertable.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|-----------------|-------------|
| *Write a function that reorders a slice of `int` in ascending order.* | *Напишите функцию, которая сортирует срез целых чисел по возрастанию.* |

---

Нужно написать функцию, которая принимает **срез `[]int`** и сортирует его (in-place), изменяя исходный массив.

### Пример использования

```go
package main

import (
	"fmt"
	"piscine"
)

func main() {
	s := []int{5, 4, 3, 2, 1, 0}
	piscine.SortIntegerTable(s)
	fmt.Println(s)
}
```

Вывод:

```
[0 1 2 3 4 5]
```

---

## Решение

```go
package piscine

// SortIntegerTable сортирует срез ints по возрастанию (in-place)
func SortIntegerTable(table []int) {
	n := len(table)

	// Bubble Sort
	for i := 0; i < n-1; i++ {
		for j := 0; j < n-1-i; j++ {
			if table[j] > table[j+1] {
				// Меняем соседние элементы местами
				table[j], table[j+1] = table[j+1], table[j]
			}
		}
	}
}
```

---

## Ключевые понятия 

| **Термин / инструмент** | **Объяснение** |
|--------------------------|----------------|
| **Срез (`[]int`)** | Динамическая структура данных в Go. Передается по ссылке на массив → изменения видны снаружи. |
| **Циклы `for`** | Основная конструкция перебора. Здесь используется вложенный `for` для сравнения соседних элементов. |
| **Swap (обмен)** | `a, b = b, a` — встроенная возможность Go менять значения без временной переменной. |
| **Алгоритм Bubble Sort** | Простой алгоритм сортировки с time complexity `O(n²)`. Простой но неэффективный для больших массивов. |
| **Сортировка in-place** | Данные изменяются внутри исходного среза, без создания нового. |


## Теория

Для решения подобных задач существуют разные алгоритмы сортировки. В рамках этого задания познакомимся с одним из них.

### Как работает Bubble Sort?

Bubble Sort это один из базовых алгоритмов сортировки:

1. Идем по массиву;
2. Сравниваем пары соседних элементов;
3. Если стоят не в правильном порядке меняем их местами;
4. Повторяем пока массив полностью не отсортируется.

Он называется пузырьковым, потому что большие элементы «всплывают» вправо как пузырьки вверх.

Алгоритм простой для понимания, его легко писать вручную, но он очень медленный(`O(n²)`)

Видео о Bubble Sort: https://youtu.be/xli_FI7CuzA

---

## Логика и пошаговый разбор кода

### 1. Получаем длину среза

```go
package piscine

func SortIntegerTable(table []int) {
	n := len(table)
```

- `len(table)` возвращает количество элементов в срезе.
- Сохраняем значение в переменную чтобы оптимизировать код и не вызывать `len` каждый раз в цикле.

---

### 2. Внешний цикл — количество проходов

```go
    for i := 0; i < n-1; i++ {
```

- Сортировка требует **n–1 проходов**, чтобы гарантировать полный порядок.
- На каждом проходе «всплывает» один большой элемент.

---

### 3. Внутренний цикл — сравниваем соседей

```go
        for j := 0; j < n-1-i; j++ {
```

- Каждый раз внутренний цикл становится короче, потому что после i проходов последние элементы уже на своих местах.

---

### 4. Проверка порядка

```go
            if table[j] > table[j+1] {
                table[j], table[j+1] = table[j+1], table[j]
            }
        }
    }
}
```

- Если два значения стоят в неправильном порядке, меняем их местами. Go позволяет менять два значения в одной строке.

---

## Заключение

Задание прокачивает:

- понимание срезов
- работу со вложенными циклами  
- умение реализовывать простейшие алгоритмы  
- навык аккуратно изменять данные in-place  
- знакомство с алгоритмами сортировки
