# Quest 3.11 — Atoi 

## Название файла Go
`atoi.go`

---

## Условия задания

| **Instruction** | **Перевод** |
|-----------------|-------------|
| *Write a function that simulates the behaviour of the `Atoi` function in Go.* | *Напишите функцию, которая имитирует работу `Atoi`: преобразует строку в `int`.* |
| *`Atoi` returns `0` if the string is not considered as a valid number.* | *Если строка невалидная — нужно вернуть `0`.* |
| *Non-valid strings will be tested. Some contain non-digit characters.* | *Будут проверяться строки с ошибками: буквы, пробелы, символы и т.д.* |
| *Handling of signs `+` or `-` does have to be taken into account.* | *Поддержка знаков `+` и `-` обязательна.* |

---

Нужно написать функцию, которая принимает строку `s` и возвращает её числовое значение типа `int`, либо `0` если строка невалидна. 
В этой версии мы заранее проверяем частные случаи (пустая строка, строка, состоящая только из одного знака) — это сделает код чище и безопаснее.

### Пример 

```go
package main

import (
	"fmt"
	"piscine"
)

func main() {
	fmt.Println(piscine.Atoi("12345"))        // 12345
	fmt.Println(piscine.Atoi("0000012345"))   // 12345
	fmt.Println(piscine.Atoi("012 345"))      // 0
	fmt.Println(piscine.Atoi("Hello World!")) // 0
	fmt.Println(piscine.Atoi("+1234"))        // 1234
	fmt.Println(piscine.Atoi("-1234"))        // -1234
	fmt.Println(piscine.Atoi("++1234"))       // 0
	fmt.Println(piscine.Atoi("-"))            // 0
}
```

---

## Решение 

```go
package piscine

func Atoi(s string) int {
	// 0. Проверка на пустую строку
	if len(s) == 0 {
		return 0
	}

	// 1. Проверка на то что строка только из знаков
	if (s[0] == '+' || s[0] == '-') && len(s) == 1 {
		return 0
	}

	// 2. Обработка знака
	sign := 1
	start := 0          /// индекс, с которого начнется парсинг цифр
	if s[0] == '-' {
		sign = -1
		start = 1
	} else if s[0] == '+' {
		start = 1
	}

	// 3. Обрабатываем цифры по одному символу
	result := 0
	for i := start; i < len(s); i++ {
		ch := s[i] // byte (ASCII) — для цифр это безопасно

		// Если встречаем любой не-цифровой символ строка невалидна
		if ch < '0' || ch > '9' {
			return 0
		}

		//Преобразуем ASCII-символ в цифру 0..9 и поэтапно собираем в result
		digit := int(ch - '0')
		result = result*10 + digit
	}

	// 4. Умножаем на знак и возвращаем
	return result * sign
}
```

---

## Ключевые понятия 

| **Термин / инструмент** | **Объяснение** |
|-------------|----------------|
| **Тип `rune`** | Каждая итерация `for range` по строке возвращает руну (Unicode-код символа). |
| **`s[i]`** | Индексирование строки возвращает `byte` (внутри — байт UTF-8). Для ASCII-цифр корректно. |
| **`len(s)`** | Число байтов в строке. Для ASCII-цифр это равно числу символов. |
| **Операция `ch - '0'`** | Превращает ASCII-символ `'0'..'9'` в его числовое значение. Например `'7' - '0' = 7`. |
| **Формула накопления числа** | `result = result*10 + digit` — стандартный способ собрать число из последовательности цифр. |

---

## Детальный пошаговый разбор кода (подробно)

### 1. Пустая строка

```go
package piscine

func Atoi(s string) int {
    if len(s) == 0 {
        return 0
    }
```

- Если `s` пустая, невозможно получить число  
- Это самая быстрая и простая проверка, избавляющая от лишних шагов дальше.

---

### 2. Строка = только знак?

```go
    if (s[0] == '+' || s[0] == '-') && len(s) == 1 {
        return 0
    }
```
---

### 3. Обработка знака

```go
    sign := 1
    start := 0
    if s[0] == '-' {
        sign = -1
        start = 1
    } else if s[0] == '+' {
        start = 1
    }
```

- `sign` это множитель который в конце применим к результату. В зависимости от значения знака (который находится под индексом 0 в строке) обновляем переменную на соответствующий.
- `start` это индекс с которого начинается обработка цифр. Если есть знак, мы его пропускаем (`start = 1`) и начнем с индекса `1`, иначе начинаем с `0`.  

---

### 4. Основной цикл

```go
result := 0
    for i := start; i < len(s); i++ {
        ch := s[i]
        if ch < '0' || ch > '9' {
            return 0
        }
    digit := int(ch - '0')
    result = result*10 + digit
    }
```
Инициализируем переменную в которой будем обновлять результат.
Цикл пройдется по всем элементам под индексом start (начиная с 0 или 1, см. выше). 

`s[i]` возвращает байт. Здесь можно безопасно использовать `s[i]` (byte), потому что мы ожидаем ASCII-цифры. 
`range` возвращает `rune`. Оба варианта допустимы, но индексация байта чуть быстрее и понятнее для простого ASCII-парсинга. 

Далее делаем проверку символа на наличие посторонних элементов. Любой пробел, буква, знак внутри сделает строку невалидной

Если проверка данного `s[i]`пройдена: 
- `ch - '0'` преобразует байт `'0'..'9'` в число `0..9`.  
- `result*10 + digit` сдвинет уже накопленные цифры на 1 разряд влево и добавит новую цифру которую мы только что проверили и перевели в `int`.

Этот цикл повторяется для каждого элемента строки `s`

---

### 5. Конечное умножение на знак и возврат

```go
    return result * sign
}
```
Как только мы собрали число, возвращаемся к знаку. Если `sign == -1`, у нас отрицательное число; иначе положительное. Умножаем знак на собранное число и возвращаем. 

---

## Примеры итераций 

1. `s = "42"`  
   - `len != 0`, не один знак. `start = 0`, `sign = 1`.  
   - i=0: ch='4' → digit=4 → result=0*10+4=4  
   - i=1: ch='2' → digit=2 → result=4*10+2=42  
   - return 42

2. `s = "-7"`  
   - `len != 0`, `len !=1` с знаком. `start=1`, `sign=-1`.  
   - i=1: ch='7' → digit=7 → result=7  
   - return 7 * -1 = -7

3. `s = "12a3"`  
   - i=0,1 ok; i=2 ch='a' → `ch < '0' || ch > '9'` true → `return 0`.  

---

## Полезные ссылки 

- strconv.Atoi: https://pkg.go.dev/strconv#Atoi  
- Статья про строки и руны (официально): https://go.dev/blog/strings  

---

## Заключение 
Полезная информация из этого упражнения:

- Как вручную перевести строку в число: проверка начала, знак, проверка каждого символа, накопление результата.  
- Почему полезна ранняя валидация: убирает лишние ветвления внутри основного цикла.  
- В чем разница между итерацией по байтам и рунам.
